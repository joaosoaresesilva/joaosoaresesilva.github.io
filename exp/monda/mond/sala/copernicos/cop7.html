<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <title>MONDEGO HYDRAULIC - PLANO DE INTERSEÇÃO</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; background: #020508; color: #00d2ff; font-family: 'Courier New', monospace; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        #map { flex: 1; filter: contrast(1.4) brightness(0.7); }
        .ui-header { background: #000; padding: 10px; border-bottom: 2px solid #0044ff; font-size: 11px; display: flex; justify-content: space-between; }
        .legend-box { position: absolute; bottom: 30px; right: 20px; background: rgba(0,0,0,0.9); border: 1px solid #0044ff; padding: 10px; z-index: 1000; font-size: 10px; }
        .tag-active { color: #0044ff; font-weight: bold; }
    </style>
</head>
<body>

<div class="ui-header">
    <div>MONDEGO HYDRAULIC ENGINE: PLANOS PERPENDICULARES</div>
    <div>CENTROIDES ATIVOS: <span id="activeCtr">---</span></div>
    <div>NÍVEL PLANO JUSANTE: <b id="planeH">---</b></div>
</div>

<div id="map"></div>

<div class="legend-box">
    <div style="color:#0044ff">● Interseção (Submerso)</div>
    <div style="color:#00ff77">● Solo Exposto (Z > Plano)</div>
    <div style="margin-top:5px; font-size:8px; opacity:0.6">MODELO: INTERSEÇÃO DE PLANOS HIDROSTÁTICOS</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    const map = L.map('map', {zoomControl: false}).setView([40.1750, -8.6000], 11);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png').addTo(map);

    const PONTOS_DENSIDADE = 2500;
    const nuvem = [];
    
    // Centroides que definem a "altura" do plano perpendicular em cada zona
    const centrosPlanos = [
        {id: "CP-BOLAO", pos: [40.22, -8.47], z_base: 15.0, dist: 2.5},
        {id: "CP-ARZILA", pos: [40.16, -8.54], z_base: 10.0, dist: 14.5},
        {id: "CP-MONTEMOR", pos: [40.17, -8.68], z_base: 6.0, dist: 25.0},
        {id: "CP-FOZ", pos: [40.14, -8.82], z_base: 2.0, dist: 40.0}
    ];

    function inicializarTerreno() {
        for (let i = 0; i < PONTOS_DENSIDADE; i++) {
            const ref = centrosPlanos[Math.floor(Math.random() * centrosPlanos.length)];
            const lat = ref.pos[0] + (Math.random() - 0.5) * 0.08;
            const lng = ref.pos[1] + (Math.random() - 0.5) * 0.15;
            
            // Cota Z do terreno (Simulação de topografia variável)
            const cotaZ = ref.z_base + (Math.random() * 8); 

            const marker = L.circleMarker([lat, lng], {
                radius: 1.1,
                weight: 0,
                fillOpacity: 0.6
            }).addTo(map);

            nuvem.push({ marker: marker, z: cotaZ, dist: ref.dist, refId: ref.id });
        }
    }

    async function processarPlanos() {
        // Simulação de valores (integrar com teus fetchs anteriores)
        let Q = 950; // Caudal
        let M = 1.4; // Maré
        
        // O plano perpendicular sobe ou desce em função de Q e M
        let hPlanoGeral = 4.0 + (Q/2000) + (M * 0.5);
        document.getElementById('planeH').innerText = hPlanoGeral.toFixed(2) + "m";
        document.getElementById('activeCtr').innerText = centrosPlanos.length;

        nuvem.forEach(p => {
            // Gradiente do plano: o plano não é perfeitamente plano, 
            // ele inclina-se ligeiramente com a distância
            let hPlanoLocal = hPlanoGeral + ( (40 - p.dist) * 0.15 ); 

            // LOGICA DE INTERSEÇÃO:
            // Se a cota do plano for maior que a cota do terreno, há inundação
            if (hPlanoLocal > p.z) {
                let profundidade = hPlanoLocal - p.z;
                let color = profundidade > 1.5 ? "#0044ff" : "#00d2ff"; // Azul escuro se for fundo
                p.marker.setStyle({ fillColor: color, fillOpacity: 0.8 });
            } else {
                p.marker.setStyle({ fillColor: "#00ff77", fillOpacity: 0.2 }); // Solo seco
            }
        });
    }

    inicializarTerreno();
    setInterval(processarPlanos, 3000);
    processarPlanos();
</script>
</body>
</html>
