<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <title>MONDEGO - BUFFER CHAIN MONITOR</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; background: #020202; color: #00d2ff; font-family: 'Courier New', monospace; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        #map { flex: 1; filter: contrast(1.2) brightness(0.8); }
        .ui-overlay { position: absolute; top: 20px; right: 20px; z-index: 1000; background: rgba(0,0,0,0.9); padding: 15px; border: 1px solid #444; width: 250px; }
        .belt-label { font-size: 10px; margin-top: 5px; display: flex; justify-content: space-between; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    </style>
</head>
<body>

<div id="map"></div>

<div class="ui-overlay">
    <div style="font-weight: bold; border-bottom: 1px solid #333; padding-bottom: 5px; margin-bottom: 10px;">CORREIAS DE VULNERABILIDADE</div>
    <div id="beltStatus"></div>
    <hr style="border:0; border-top:1px solid #333; margin:10px 0;">
    <small>CAUDAL: <span id="valQ" style="color:#fff">---</span> m3/s</small>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    const map = L.map('map', {zoomControl: false}).setView([40.1850, -8.5800], 12);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png').addTo(map);

    // Eixo central do rio (simplificado) para calcular as correias
    const leitoRio = [
        [40.210, -8.430], [40.200, -8.480], [40.180, -8.550], 
        [40.160, -8.650], [40.140, -8.750], [40.130, -8.850]
    ];
    const polylineRio = L.polyline(leitoRio, {color: 'transparent'}).addTo(map);

    const distanciasBuffers = [0, 1, 10, 20, 100, 200]; // Metros da margem
    const pontosNuvem = [];

    // Gerador de Correias
    function gerarCorreias() {
        distanciasBuffers.forEach((distBuffer, bIndex) => {
            // Gerar 200 pontos por correia ao longo do rio
            for (let i = 0; i < 200; i++) {
                const perc = i / 200;
                // Obter ponto no eixo do rio
                const pBase = L.GeometryUtil.interpolateOnLine(map, polylineRio, perc).latLng;
                
                // Desviar o ponto lateralmente para criar a correia (conversão aprox graus/metros)
                const offset = (distBuffer / 111000) * (i % 2 === 0 ? 1 : -1);
                const pos = [pBase.lat + (Math.random() * 0.0001), pBase.lng + offset];
                
                const marker = L.circleMarker(pos, {
                    radius: 1.5,
                    weight: 0,
                    fillOpacity: 0.7
                }).addTo(map);

                pontosNuvem.push({
                    id: `B${distBuffer}-P${i}`,
                    marker: marker,
                    distMargem: distBuffer,
                    distFoz: (1 - perc) * 40,
                    z: 5 + (distBuffer * 0.1) // Cota sobe conforme se afasta do rio
                });
            }
        });
    }

    function atualizarHidrodinamica() {
        const Q = 1000 + (Math.sin(Date.now()/5000) * 200); // Simulação de pulso de caudal
        document.getElementById('valQ').innerText = Q.toFixed(0);
        
        const beltStatusDiv = document.getElementById('beltStatus');
        beltStatusDiv.innerHTML = '';

        distanciasBuffers.forEach(dist => {
            let hPlano = 5.0 + (Q/2500);
            let totalIn = 0;
            let totalBelt = 0;

            pontosNuvem.filter(p => p.distMargem === dist).forEach(p => {
                totalBelt++;
                // O plano de inundação cruza a cota Z do ponto na correia
                if (hPlano > p.z) {
                    p.marker.setStyle({fillColor: '#0044ff'}); // Azul (Submerso)
                    totalIn++;
                } else if (hPlano > p.z - 0.5) {
                    p.marker.setStyle({fillColor: '#00d2ff'}); // Azul Claro (Risco)
                } else {
                    p.marker.setStyle({fillColor: '#00ff77'}); // Verde (Seco)
                }
            });

            // UI Feedback
            const percent = (totalIn / totalBelt) * 100;
            beltStatusDiv.innerHTML += `
                <div class="belt-label">
                    <span>Correia ${dist}m</span>
                    <span style="color:${percent > 0 ? '#ff4444' : '#00ff77'}">${percent.toFixed(0)}% ATIVA</span>
                </div>`;
        });
    }

    // Nota: L.GeometryUtil requer a inclusão do plugin Leaflet.GeometryUtil
    // Para este exemplo, usaremos uma interpolação linear simples nativa:
    L.GeometryUtil = {
        interpolateOnLine: function(map, line, percent) {
            const pts = line.getLatLngs();
            const index = Math.floor(percent * (pts.length - 1));
            return { latLng: pts[index] };
        }
    };

    gerarCorreias();
    setInterval(atualizarHidrodinamica, 2000);
    atualizarHidrodinamica();
</script>
</body>
</html>
