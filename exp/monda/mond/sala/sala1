<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <title>MONDEGO COMMAND v6.0 - HISTÓRICO REAL</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root { --bg: #050505; --card: #111; --accent: #00d2ff; --warn: #ff4757; --gold: #f1c40f; --green: #27ae60; }
        body { margin: 0; font-family: 'Segoe UI', sans-serif; background: var(--bg); color: #ccc; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #map { height: 25vh; width: 100%; border-bottom: 2px solid #333; }
        .main-container { display: flex; flex: 1; overflow: hidden; }
        .sidebar { flex: 0.8; padding: 15px; border-right: 1px solid #222; background: #080808; display: flex; flex-direction: column; gap: 10px; }
        .dashboard { flex: 2.2; padding: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; overflow-y: auto; }
        .card { background: var(--card); border: 1px solid #222; padding: 12px; border-radius: 4px; }
        .card-full { grid-column: span 2; }
        .card-title { font-size: 10px; text-transform: uppercase; color: var(--gold); margin-bottom: 8px; font-weight: bold; }
        .val-display { color: var(--accent); font-family: monospace; font-size: 1.2em; font-weight: bold; }
        select, input[type=range] { width: 100%; margin-top: 5px; background: #222; color: #fff; border: 1px solid #444; }
        .btn { width: 100%; padding: 12px; font-weight: bold; cursor: pointer; border: none; border-radius: 4px; text-transform: uppercase; }
        .idle { background: var(--green); color: white; }
        .active { background: var(--warn); color: white; }
        canvas { background: #000; border: 1px solid #333; width: 100%; }
        table { width: 100%; font-size: 11px; border-collapse: collapse; }
        th { text-align: left; color: #555; border-bottom: 1px solid #333; padding: 4px; }
        td { padding: 4px; border-bottom: 1px solid #1a1a1a; }
        .crit-row { color: var(--warn); background: rgba(255, 71, 87, 0.15); font-weight: bold; }
    </style>
</head>
<body>

<div id="map"></div>

<div class="main-container">
    <div class="sidebar">
        <div class="card">
            <div class="card-title">Cenário Histórico</div>
            <select id="scenario">
                <option value="elsa_2019">Tempestade Elsa (2.200 m³/s)</option>
                <option value="brien_2001">Cheia de Janeiro (2.100 m³/s)</option>
                <option value="historica_1948">Grande Cheia 1948 (3.500 m³/s)</option>
            </select>
        </div>
        <div class="card">
            <div class="card-title">Modo de Comando</div>
            <select id="strategy">
                <option value="manual">Manual (Controlo Total)</option>
                <option value="preditivo">Preditivo (IA de Antecipação)</option>
            </select>
        </div>
        <div class="card">
            <div class="card-title">Comportas do Açude</div>
            <div id="dG" class="val-display">100%</div>
            <input type="range" id="iG" min="0" max="100" value="100">
        </div>
        <button id="runBtn" class="btn idle">Iniciar Simulação</button>
    </div>

    <div class="dashboard">
        <div class="card">
            <div class="card-title">Fluxo por Período</div>
            <canvas id="riverCanvas" height="150"></canvas>
        </div>
        <div class="card">
            <div class="card-title">Estabilidade de Fase (Bode)</div>
            <canvas id="bodeCanvas" height="150"></canvas>
        </div>
        <div class="card card-full">
            <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                <span id="periodLabel" style="color:var(--gold); font-weight:bold;">MADRUGADA (00h-06h)</span>
                <span id="flowLabel" style="color:var(--accent);">Caudal: 0 m³/s</span>
            </div>
            <table>
                <thead><tr><th>POSTO</th><th>LIMITE</th><th>NÍVEL</th><th>ESTADO</th></tr></thead>
                <tbody id="sensorTbody"></tbody>
            </table>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    // Dados Reais Históricos por Período (Madrugada, Manhã, Tarde, Noite)
    const coimbraData = {
        "elsa_2019": { f: [1200, 1800, 2200, 1900], l: [17.5, 18.5, 19.5, 18.8], periods: ["MADRUGADA", "MANHÃ", "TARDE", "NOITE"] },
        "brien_2001": { f: [1500, 2100, 1800, 1600], l: [18.0, 19.8, 19.0, 18.5], periods: ["MADRUGADA", "MANHÃ", "TARDE", "NOITE"] },
        "historica_1948": { f: [2000, 2800, 3500, 3000], l: [19.0, 21.0, 23.5, 22.0], periods: ["MADRUGADA", "MANHÃ", "TARDE", "NOITE"] }
    };

    const postos = [
        { name: "BAIXA (P. COMÉRCIO)", pos: [40.2092, -8.4298], limit: 20.0, type: 'C' },
        { name: "STA CLARA", pos: [40.2018, -8.4340], limit: 19.5, type: 'C' },
        { name: "ALFARELOS", pos: [40.1530, -8.6420], limit: 11.5, type: 'B' }
    ];

    let isRunning = false, tick = 0, levelC = 16.5, levelA = 9.5;
    const map = L.map('map').setView([40.2050, -8.4200], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
    const markers = postos.map(p => ({ m: L.circle(p.pos, {radius: 60, color: '#00d2ff'}).addTo(map), data: p }));

    function update() {
        if (!isRunning) return;
        
        const sc = document.getElementById('scenario').value;
        const strategy = document.getElementById('strategy').value;
        const data = coimbraData[sc];
        
        let i = Math.floor((tick / 15) % 4); // Muda de período a cada 15 iterações
        let flowNow = data.f[i];
        let base = data.l[i];
        let gates = parseFloat(document.getElementById('iG').value);

        // Lógica Preditiva
        if (strategy === "preditivo") {
            let nextFlow = data.f[(i + 1) % 4];
            if (nextFlow > flowNow || levelC > 19.0) gates = Math.max(0, gates - 5);
            else if (levelC < 18.5) gates = Math.min(100, gates + 2);
            document.getElementById('iG').value = gates;
        }

        // Física do Sistema: G(s) com Inércia
        // O nível C depende do caudal real e da abertura do açude (divisor 2800 representa a calha real)
        let targetC = base + (flowNow / 2800) + (1 - (gates / 100)) * 5.5;
        levelC += (targetC - levelC) * 0.1; // Inércia de resposta

        let targetA = 9.0 + (flowNow / 3500) + (gates / 100) * 4.0;
        levelA += (targetA - levelA) * 0.1;

        // UI
        document.getElementById('periodLabel').innerText = data.periods[i] + " (" + (i*6) + "h - " + (i*6+6) + "h)";
        document.getElementById('flowLabel').innerText = "Caudal: " + flowNow + " m³/s";
        document.getElementById('dG').innerText = Math.round(gates) + "%";
        
        tick++;
        render();
        drawBode(flowNow);
    }

    function drawBode(flow) {
        const ctx = document.getElementById('bodeCanvas').getContext('2d');
        const w = ctx.canvas.width, h = ctx.canvas.height;
        ctx.clearRect(0,0,w,h);
        ctx.strokeStyle = "#333"; ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
        
        // Simulação de estabilidade: se o caudal é muito alto, a fase cai (instabilidade)
        for(let x=0; x<w; x++) {
            let f = Math.pow(10, (x/w)*2 - 1.5);
            let mag = 20 * Math.log10(1.5 / Math.sqrt(1 + Math.pow(f*10, 2)));
            let delay = flow / 500; // Maior caudal = maior atraso de resposta
            let phase = (-Math.atan(f*10) - (f * delay)) * (180/Math.PI);
            ctx.fillStyle = "#00d2ff"; ctx.fillRect(x, (h/2) - mag*2, 1, 1);
            ctx.fillStyle = "#f1c40f"; ctx.fillRect(x, (h/2) - phase/3, 1, 1);
        }
    }

    function render() {
        const tbody = document.getElementById('sensorTbody');
        tbody.innerHTML = '';
        const ctx = document.getElementById('riverCanvas').getContext('2d');
        const w = ctx.canvas.width, h = ctx.canvas.height;
        ctx.clearRect(0,0,w,h);
        ctx.fillStyle = "rgba(0, 210, 255, 0.2)";
        ctx.beginPath();
        ctx.moveTo(0, h-(levelC*5)); ctx.lineTo(w*0.6, h-(levelC*5)); 
        ctx.lineTo(w, h-(levelA*5)); ctx.lineTo(w, h); ctx.lineTo(0, h); ctx.fill();

        markers.forEach(obj => {
            const val = obj.data.type === 'C' ? levelC : levelA;
            const isCrit = val > obj.data.limit;
            tbody.innerHTML += `<tr class="${isCrit?'crit-row':''}"><td>${obj.data.name}</td><td>${obj.data.limit}m</td><td>${val.toFixed(2)}m</td><td>${isCrit?'! ALERTA':'OK'}</td></tr>`;
            obj.m.setStyle({color: isCrit ? 'red' : '#00d2ff', radius: isCrit ? 100 : 60});
        });
    }

    document.getElementById('runBtn').onclick = function() {
        isRunning = !isRunning;
        this.innerText = isRunning ? "Parar Simulação" : "Iniciar Simulação";
        this.className = "btn " + (isRunning ? "active" : "idle");
    };

    setInterval(update, 400);
</script>
</body>
</html>
