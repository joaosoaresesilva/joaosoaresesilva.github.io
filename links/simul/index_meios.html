<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simulador de Propagação Ferramenta de Estudo - Tendo em Conta o Vento</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .form-section { margin-bottom: 20px; padding: 10px; background-color: #fcecec; border-left: 4px solid #c00; }
    label { display: block; margin-bottom: 8px; }
    input[type="range"], input[type="number"] { width: 100%; max-width: 300px; }
    canvas { margin-top: 20px; border: 2px solid #000; max-width: 100%; height: auto; cursor: crosshair; display: block; touch-action: none; }
    .info { 
        background-color: rgba(244, 244, 244, 0.9);
        padding: 10px;
        border-left: 4px solid #1f77b4;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0,0,0,0.2);
        position: absolute;
        top: 20px;
        right: 20px;
        max-width: 300px;
        z-index: 10;
    }
    .escala-section { margin-top: 20px; background-color: #d0f0d0; padding: 10px; border-left: 4px solid #4CAF50; }
    .controls button { margin-right: 10px; padding: 8px 12px; }
    .controls label { display:inline-block; margin-left:10px; }
    #canvasDirecaoVento { width: 100px; height: 100px; border: 1px solid black; cursor: pointer; }
    #btnContinuar { display: none; }
  </style>
</head>
<body>
  <h1>Simulador de Propagação e Combate</h1>
  <p><strong>Objetivo:</strong> Ferramenta de Estudo: Como o Vento Afeta a Propagação com base na velocidade/direção do vento e considerando a escala da imagem.</p>
  
  <div class="info" id="resultado">
    <p><em>Clique no mapa para definir o(s) ponto(s) onde houve suposta ignição do incêndio.</em></p>
  </div>
  
  <div class="form-section">
    <h3>Parâmetros do Incêndio</h3>
    <label>Velocidade do Vento (km/h):
      <input type="range" id="velocidadeVento" min="0" max="150" value="10" oninput="velocidadeVentoOutput.value = this.value; desenharBase();">
      <output id="velocidadeVentoOutput">10</output> km/h
    </label>
    
    <label>Direção do Vento (0° = Norte):
      <canvas id="canvasDirecaoVento"></canvas>
      <output id="direcaoVentoOutput">45</output> °
    </label>
    
    <label>Taxa de Propagação Base (sem vento):
      <input type="range" id="taxaPropagacao" min="10" max="200" step="10" value="50" oninput="taxaPropagacaoOutput.value = this.value; desenharBase();">
      <output id="taxaPropagacaoOutput">50</output> m/h
    </label>
  </div>
  
  <div class="form-section controls">
    <button type="button" onclick="iniciarSimulacao()">Iniciar / Reiniciar Simulação</button>
    <button type="button" onclick="pararSimulacao()">Parar Simulação</button>
    <label><input type="checkbox" id="mostrarSemireta" checked onchange="desenharBase()"> Mostrar semiretas na frente do incêndio</label>
    <label><input type="checkbox" id="mostrarGrelha" checked onchange="desenharBase()"> Mostrar Grelha</label>
  </div>
  
  <div class="escala-section">
    <h3>Medição de Escala</h3>
    <p><em>(Opcional) Clique nos dois extremos da barra de escala em baixo no mapa para calibração.</em></p>
    <label>Escala (metros por pixel):
      <input type="number" id="escala" min="0.01" step="0.01" value="7.6" onchange="desenharBase()"> m/pixel
    </label>
    <label>Litros de água por m²:
      <input type="number" id="litrosPorM2" min="1" step="1" value="10" onchange="desenharBase()">
    </label>
    <label>Capacidade do autotanque (litros):
      <input type="number" id="capacidadeCarro" min="1000" step="100" value="5000" onchange="desenharBase()">
    </label>
    <button onclick="ativarMedicaoEscala()">Ativar Medição da Escala</button>
    <div id="escalaInfo" style="margin-top:10px;"></div>
  </div>
  
  <canvas id="canvas"></canvas>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imagem = new Image();
    const canvasDirecaoVento = document.getElementById('canvasDirecaoVento');
    const ctxDirecaoVento = canvasDirecaoVento.getContext('2d');
    
    let medirEscala = false;
    let escalaPonto1 = null;
    let pontosIgnicao = [];
    let simulationInterval = null;
    let tempoSimulado = 0;
    let areaArdiaTotal = 0;
    let frentesIncendio = []; 
    let direcaoVento = 45; 
    
    imagem.onload = function() {
      const maxWidth = canvas.parentElement.offsetWidth;
      const aspectRatio = imagem.width / imagem.height;
      canvas.width = Math.min(imagem.width, maxWidth);
      canvas.height = canvas.width / aspectRatio;
      if (imagem.width < maxWidth) {
          canvas.width = imagem.width;
          canvas.height = imagem.height;
      }
      desenharBase();
    }
    imagem.src = '../aerea1.jpg';
    
    canvasDirecaoVento.width = 100;
    canvasDirecaoVento.height = 100;
    desenharSeletorVento();
    
    let isDragging = false;
    canvasDirecaoVento.addEventListener('mousedown', function(e) {
      isDragging = true;
      atualizarDirecaoVento(e);
    });
    canvasDirecaoVento.addEventListener('mousemove', function(e) {
      if (isDragging) {
        atualizarDirecaoVento(e);
      }
    });
    canvasDirecaoVento.addEventListener('mouseup', function() {
      isDragging = false;
    });
    canvasDirecaoVento.addEventListener('mouseout', function() {
      isDragging = false;
    });
    
    function atualizarDirecaoVento(e) {
      const rect = canvasDirecaoVento.getBoundingClientRect();
      const x = e.clientX - rect.left - 50;
      const y = e.clientY - rect.top - 50;
      let angle = Math.atan2(y, x);
      direcaoVento = (360 + (angle * 180 / Math.PI) + 90) % 360;
      document.getElementById('direcaoVentoOutput').innerText = direcaoVento.toFixed(0);
      desenharSeletorVento();
      desenharBase();
    }
    
    function desenharSeletorVento() {
      ctxDirecaoVento.clearRect(0, 0, 100, 100);
      const centerX = 50;
      const centerY = 50;
      const radius = 40;
      ctxDirecaoVento.beginPath();
      ctxDirecaoVento.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctxDirecaoVento.strokeStyle = '#333';
      ctxDirecaoVento.lineWidth = 2;
      ctxDirecaoVento.stroke();
      ctxDirecaoVento.font = '12px Arial';
      ctxDirecaoVento.textAlign = 'center';
      ctxDirecaoVento.textBaseline = 'middle';
      ctxDirecaoVento.fillStyle = '#333';
      ctxDirecaoVento.fillText('N', centerX, centerY - radius - 8);
      ctxDirecaoVento.fillText('S', centerX, centerY + radius + 8);
      ctxDirecaoVento.fillText('E', centerX + radius + 8, centerY);
      ctxDirecaoVento.fillText('W', centerX - radius - 8, centerY);
      const angleRad = (direcaoVento - 90 + 360) % 360 * Math.PI / 180;
      const arrowX = centerX + Math.cos(angleRad) * radius;
      const arrowY = centerY + Math.sin(angleRad) * radius;
      ctxDirecaoVento.beginPath();
      ctxDirecaoVento.moveTo(centerX, centerY);
      ctxDirecaoVento.lineTo(arrowX, arrowY);
      ctxDirecaoVento.strokeStyle = '#c00';
      ctxDirecaoVento.lineWidth = 3;
      ctxDirecaoVento.stroke();
      ctxDirecaoVento.beginPath();
      const headLen = 6;
      ctxDirecaoVento.moveTo(arrowX, arrowY);
      ctxDirecaoVento.lineTo(arrowX - headLen * Math.cos(angleRad - Math.PI/6), arrowY - headLen * Math.sin(angleRad - Math.PI/6));
      ctxDirecaoVento.lineTo(arrowX - headLen * Math.cos(angle + Math.PI/6), arrowY - headLen * Math.sin(angle + Math.PI/6));
      ctxDirecaoVento.closePath();
      ctxDirecaoVento.fillStyle = '#c00';
      ctxDirecaoVento.fill();
    }
    
    function desenharBase() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(imagem, 0, 0, canvas.width, canvas.height);
        
        if (document.getElementById('mostrarGrelha').checked) {
            desenharGrelha();
        }
        
        pontosIgnicao.forEach(ponto => {
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(ponto.x, ponto.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        });
        
        if (frentesIncendio.length > 0) {
            frentesIncendio.forEach(frenteSimulacao => {
                const corBase = [255, 255, 0];
                const corFinal = [139, 0, 0];
                frenteSimulacao.forEach((frente, index) => {
                    const progresso = Math.min(index / 24, 1);
                    const r = corBase[0] + (corFinal[0] - corBase[0]) * progresso;
                    const g = corBase[1] + (corFinal[1] - corBase[1]) * progresso;
                    const b = corBase[2] + (corFinal[2] - corBase[2]) * progresso;
                    
                    ctx.beginPath();
                    ctx.moveTo(frente.p1.x, frente.p1.y);
                    ctx.lineTo(frente.p2.x, frente.p2.y);
                    ctx.strokeStyle = `rgb(${r},${g},${b})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            });
        }
        
        if (document.getElementById('mostrarSemireta').checked && frentesIncendio.length > 0) {
            frentesIncendio.forEach(frenteSimulacao => {
                if(frenteSimulacao.length > 0) {
                    const ultima = frenteSimulacao[frenteSimulacao.length - 1];
                    const anguloRad = ((direcaoVento - 90 + 360) % 360) * Math.PI / 180;
                    desenharSemiretas(ultima.center, ultima.p1, ultima.p2, anguloRad);
                }
            });
        }
        
        atualizarResultado();
    }
    
    function getCanvasCoordinates(event) {
        const rectCanvas = canvas.getBoundingClientRect();
        let clientX, clientY;
        if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }
        const scaleX = canvas.width / rectCanvas.width;
        const scaleY = canvas.height / rectCanvas.height;
        return { x: (clientX - rectCanvas.left) * scaleX, y: (clientY - rectCanvas.top) * scaleY };
    }
    
    canvas.addEventListener('click', function(e) {
        const { x, y } = getCanvasCoordinates(e);
        if (medirEscala) {
            if (!escalaPonto1) {
                escalaPonto1 = { x, y };
                document.getElementById('escalaInfo').innerText = 'Selecione o segundo ponto da escala...';
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
            } else {
                const escalaPonto2 = { x, y };
                const distanciaPixels = Math.sqrt(Math.pow(escalaPonto2.x - escalaPonto1.x, 2) + Math.pow(escalaPonto2.y - escalaPonto1.y, 2));
                const metros = prompt("Introduza a distância real em metros entre os pontos:");
                if (metros && !isNaN(metros)) {
                    const escalaCalculada = parseFloat(metros) / distanciaPixels;
                    document.getElementById('escala').value = escalaCalculada.toFixed(4);
                    document.getElementById('escalaInfo').innerText = `Escala calculada: ${escalaCalculada.toFixed(4)} m/pixel`;
                    atualizarResultado();
                 }
                medirEscala = false;
                escalaPonto1 = null;
                desenharBase();
            }
        } else if (!simulationInterval) {
            pontosIgnicao.push({ x, y });
            document.getElementById('resultado').innerHTML = `<p>${pontosIgnicao.length} ponto(s) de ignição definido(s). Clique em "Iniciar / Reiniciar Simulação" ou adicione mais pontos.</p>`;
            desenharBase();
        }
    });
    
    document.getElementById('mostrarGrelha').addEventListener('change', desenharBase);
    
    function ativarMedicaoEscala() {
      pararSimulacao();
      medirEscala = true;
      escalaPonto1 = null;
      document.getElementById('escalaInfo').innerText = 'Clique no primeiro ponto da escala...(canto inferior direito)';
    }
    
    function pararSimulacao() {
        if (!simulationInterval) return;
        clearInterval(simulationInterval);
        simulationInterval = null;
        
        const finalResult = document.getElementById('resultado').innerHTML;
        document.getElementById('resultado').innerHTML = '<h3>Simulação Parada</h3>' + finalResult + '<p><em>Para recomeçar, clique em "Iniciar / Reiniciar Simulação". Para uma nova simulação, clique noutro ponto do mapa.</em></p>';
    }

    function iniciarSimulacao() {
        if (pontosIgnicao.length === 0) {
            alert("Por favor, defina pelo menos um ponto de ignição clicando no mapa.");
            return;
        }
        if (simulationInterval) {
            pararSimulacao();
        }
        
        frentesIncendio = pontosIgnicao.map(ponto => ([{
            p1: { x: ponto.x - 1, y: ponto.y },
            p2: { x: ponto.x + 1, y: ponto.y },
            center: { x: ponto.x, y: ponto.y },
            area: 0
        }]));
        
        desenharBase();
        tempoSimulado = 0;
        areaArdiaTotal = 0;
        
        simulationInterval = setInterval(atualizarSimulacao, 1000);
    }
    
    function atualizarSimulacao() {
        tempoSimulado += 5;
        
        const velocidadeVento_kmh = parseFloat(document.getElementById('velocidadeVento').value);
        const taxaBase_mh = parseFloat(document.getElementById('taxaPropagacao').value);
        const escala = parseFloat(document.getElementById('escala').value);
        const fatorVento = 1 + (velocidadeVento_kmh / 10);
        
        const taxaPropagacaoTotal_mh = taxaBase_mh * fatorVento;
        const propagacao_metros_5min = (taxaPropagacaoTotal_mh / 60) * 5;
        const propagacao_pixels_5min = propagacao_metros_5min / escala;
        
        const propagacaoLateral_mh = taxaBase_mh * 0.2;
        const propagacaoLateral_metros_5min = (propagacaoLateral_mh / 60) * 5;
        const propagacaoLateral_pixels_5min = propagacaoLateral_metros_5min / escala;
        
        const anguloRad = ((direcaoVento - 90 + 360) % 360) * Math.PI / 180;
        
        const dx = Math.cos(anguloRad) * propagacao_pixels_5min;
        const dy = Math.sin(anguloRad) * propagacao_pixels_5min;
        const dx_lat = -Math.sin(anguloRad) * propagacaoLateral_pixels_5min;
        const dy_lat = Math.cos(anguloRad) * propagacaoLateral_pixels_5min;

        frentesIncendio = frentesIncendio.map(frenteSimulacao => {
            const ultimaFrente = frenteSimulacao[frenteSimulacao.length - 1];
            
            const novaFrente = {
                p1: { x: ultimaFrente.p1.x + dx - dx_lat, y: ultimaFrente.p1.y + dy - dy_lat },
                p2: { x: ultimaFrente.p2.x + dx + dx_lat, y: ultimaFrente.p2.y + dy + dy_lat },
                center: { x: ultimaFrente.center.x + dx, y: ultimaFrente.center.y + dy }
            };
            
            const dist_p1 = Math.sqrt(Math.pow(novaFrente.p1.x - ultimaFrente.p1.x, 2) + Math.pow(novaFrente.p1.y - ultimaFrente.p1.y, 2));
            const dist_p2 = Math.sqrt(Math.pow(novaFrente.p2.x - ultimaFrente.p2.x, 2) + Math.pow(novaFrente.p2.y - ultimaFrente.p2.y, 2));
            const distMedia_pixels = (dist_p1 + dist_p2) / 2;
            
            const larguraFrente_pixels = Math.sqrt(Math.pow(ultimaFrente.p1.x - ultimaFrente.p2.x, 2) + Math.pow(ultimaFrente.p1.y - ultimaFrente.p2.y, 2));
            const areaAdicional_pixels = larguraFrente_pixels * distMedia_pixels;
            const areaAdicional_m2 = areaAdicional_pixels * (escala * escala);
            areaArdiaTotal += areaAdicional_m2;
            
            novaFrente.area = ultimaFrente.area + areaAdicional_m2;
            frenteSimulacao.push(novaFrente);
            return frenteSimulacao;
        });
        desenharBase();
    }
    
    function atualizarResultado() {
        const areaPorHora = (areaArdiaTotal / tempoSimulado) * 60 || 0;
        const litrosPorM2 = parseFloat(document.getElementById('litrosPorM2').value);
        const capacidadeCarro = parseFloat(document.getElementById('capacidadeCarro').value);
        const litrosNecessarios = areaArdiaTotal * litrosPorM2;
        const carrosNecessarios = Math.ceil(litrosNecessarios / capacidadeCarro) || 0;
        
        const tempo_horas_dec = (tempoSimulado / 60).toFixed(1);
    
        const resultadoHTML = `
            <h3>Resultados da Simulação</h3>
            <ul>
                <li><strong>Tempo Simulado:</strong> ${tempoSimulado} minutos (${tempo_horas_dec} h)</li>
                <li><strong>Área Total Ardida:</strong> ${areaArdiaTotal.toFixed(2)} m²</li>
                <li><strong>Litros de Água Necessários:</strong> ${litrosNecessarios.toFixed(0)} L</li>
                <li><strong>Carros de Bombeiros Necessários:</strong> ${carrosNecessarios}</li>
                <li><strong>Taxa Média:</strong> ${areaPorHora.toFixed(2)} m²/hora</li>
            </ul>
        `;
        document.getElementById('resultado').innerHTML = resultadoHTML;
    }
    
    function desenharSemiretas(center, p1, p2, anguloRad) {
        const ux = Math.cos(anguloRad);
        const uy = Math.sin(anguloRad);
        const x0 = center.x;
        const y0 = center.y;
        
        const end = getCanvasIntersection(x0, y0, ux, uy);
        if (end) {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = 'rgba(0,150,255,0.9)';
            ctx.lineWidth = 3;
            ctx.setLineDash([8,6]);
            ctx.stroke();
            const headLen = 10;
            const angle = Math.atan2(end.y - y0, end.x - x0);
            ctx.beginPath();
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(end.x - headLen * Math.cos(angle - Math.PI/6), end.y - headLen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(end.x - headLen * Math.cos(angle + Math.PI/6), end.y - headLen * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fillStyle = 'rgba(0,150,255,0.9)';
            ctx.fill();
            
            const horas = Math.floor(tempoSimulado / 60);
            const minutos = tempoSimulado % 60;
            const tempoText = `${horas.toString().padStart(2, '0')}:${minutos.toString().padStart(2, '0')}`;
            
            const textX = (x0 + end.x) / 2;
            const textY = (y0 + end.y) / 2;

            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'blue';
            ctx.font = 'bold 24px Arial';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.strokeText(tempoText, textX, textY);
            ctx.fillText(tempoText, textX, textY);
            ctx.restore();
        }
        
        // Novo código para desenhar os carros a cada hora
        const escala = parseFloat(document.getElementById('escala').value);
        const litrosPorM2 = parseFloat(document.getElementById('litrosPorM2').value);
        const capacidadeCarro = parseFloat(document.getElementById('capacidadeCarro').value);
        
        for (let i = 60; i <= tempoSimulado; i += 60) {
            const frenteAnterior = frentesIncendio[0].find(f => (f.area * (escala*escala)) >= ((i - 60) * litrosPorM2));
            const frenteAtual = frentesIncendio[0].find(f => (f.area * (escala*escala)) >= (i * litrosPorM2));
            
            if (frenteAnterior && frenteAtual) {
                const areaPeriodo = frenteAtual.area - frenteAnterior.area;
                const litrosNecessarios = areaPeriodo * litrosPorM2;
                const carrosNecessarios = Math.ceil(litrosNecessarios / capacidadeCarro) || 0;
                
                const centro = {
                    x: (frenteAnterior.center.x + frenteAtual.center.x) / 2,
                    y: (frenteAnterior.center.y + frenteAtual.center.y) / 2
                };
                
                const text = `🚒 ${carrosNecessarios} | ${litrosNecessarios.toFixed(0)}L`;
                
                ctx.save();
                ctx.translate(centro.x, centro.y);
                const angleRad = ((direcaoVento - 90 + 360) % 360) * Math.PI / 180;
                ctx.rotate(angleRad + Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'blue';
                ctx.font = 'bold 16px Arial';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.strokeText(text, 0, -20);
                ctx.fillText(text, 0, -20);
                ctx.restore();
            }
        }
        
    }
    
    function getCanvasIntersection(x0, y0, ux, uy) {
        const candidates = [];
        if (Math.abs(ux) > 1e-9) {
            let t = (0 - x0) / ux;
            if (t > 0) {
                const y = y0 + t * uy;
                if (y >= 0 && y <= canvas.height) candidates.push({t, x:0, y});
            }
            t = (canvas.width - x0) / ux;
            if (t > 0) {
                const y = y0 + t * uy;
                if (y >= 0 && y <= canvas.height) candidates.push({t, x:canvas.width, y});
            }
        }
        if (Math.abs(uy) > 1e-9) {
            let t = (0 - y0) / uy;
            if (t > 0) {
                const x = x0 + t * ux;
                if (x >= 0 && x <= canvas.width) candidates.push({t, x, y:0});
            }
            t = (canvas.height - y0) / uy;
            if (t > 0) {
                const x = x0 + t * ux;
                if (x >= 0 && x <= canvas.width) candidates.push({t, x, y:canvas.height});
            }
        }
        if (candidates.length === 0) return null;
        candidates.sort((a,b) => a.t - b.t);
        return candidates[0];
    }
    
    function desenharGrelha() {
        const escala_m_por_pixel = parseFloat(document.getElementById('escala').value);
        if (isNaN(escala_m_por_pixel) || escala_m_por_pixel <= 0) return;
        const tamanhoCelula_m = 100;
        const gridSize_pixels = tamanhoCelula_m / escala_m_por_pixel;
        if (gridSize_pixels <= 5) return;
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.7)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 2]);
        for (let x = 0; x < canvas.width; x += gridSize_pixels) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        for (let y = 0; y < canvas.height; y += gridSize_pixels) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        ctx.setLineDash([]);
    }
  </script>
</body>
</html>
